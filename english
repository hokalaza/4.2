local DrRayLibrary = loadstring(game:HttpGet("https://raw.githubusercontent.com/AZYsGithub/DrRay-UI-Library/main/DrRay.lua"))()
local window       = DrRayLibrary:Load("Hokalaza 4.2", "Default")
local tab          = DrRayLibrary.newTab("main", "ImageIdHere")
local Players    = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInput  = game:GetService("UserInputService")
local StarterGui = game:GetService("StarterGui")
local Workspace  = game:GetService("Workspace")
local player = Players.LocalPlayer
local char   = player.Character or player.CharacterAdded:Wait()
player.CharacterAdded:Connect(function(c) char = c end)
local camera = workspace.CurrentCamera
_G.BumpDistance           = 12
_G.DiveDistance           = 20
_G.FollowDistance         = 15
_G.OnlyBumpWhenAutoFollow = false
_G.AutoAimMiddleOnFollow  = false
_G.DesiredWalkSpeed       = 16
local autoFollow    = false
local autoDive      = false
local autoReceive   = false
local followKey     = nil
local diveKey       = nil
local speedOverride = false
local markers  = {}
local ballData = {}
local function getDesiredReceivePowerFromPosition(pos)
    local dx = pos.X
    local dz = pos.Z
    local dist2D = math.sqrt(dx*dx + dz*dz)
    if dist2D >= 44.85 then
        return 5
    elseif dist2D >= 35.52 then
        return 4
    elseif dist2D >= 28.27 then
        return 3
    elseif dist2D >= 23 then
        return 2
    elseif dist2D >= 21.25 then
        return 2
    elseif dist2D >= 16.47 then
        return 1
    else
        return 1
    end
end
local function getCurrentPower()
    local gui = player:FindFirstChild("PlayerGui")
    if not gui then return nil end
    local hud = gui:FindFirstChild("HUD")
    if not hud then return nil end
    local bars = hud:FindFirstChild("Bars")
    if not bars then return nil end
    local power = bars:FindFirstChild("Power")
    if not power then return nil end
    local amount = power:FindFirstChild("Amount")
    if not amount or not amount:IsA("TextLabel") then return nil end
    local text = amount.Text
    local current = tonumber(text:match("^(%d+)"))
    return current
end
local function adjustPowerTo(desiredPower)
    if not char or not char.Parent then return end
    local current = getCurrentPower()
    if not current or not desiredPower then return end
    local actions = require(player.Character.CharacterScript.CharacterActions)
    if current < desiredPower then
        actions:PowerUp()
    elseif current > desiredPower then
        actions:PowerDown()
    end
end
local function waitForKeyBind(label, setter)
    StarterGui:SetCore("SendNotification", {
        Title    = label,
        Text     = "Press any key to bind " .. label,
        Duration = 5
    })
    local conn
    conn = UserInput.InputBegan:Connect(function(inp, gp)
        if not gp and inp.UserInputType == Enum.UserInputType.Keyboard then
            setter(inp.KeyCode)
            StarterGui:SetCore("SendNotification", {
                Title    = label,
                Text     = "Bound to " .. inp.KeyCode.Name,
                Duration = 5
            })
            conn:Disconnect()
        end
    end)
end
local camLoop
local netMiddle = Vector3.new(0, 10, 0)
local function toggleCameraLock(on)
    if on then
        camera.CameraType = Enum.CameraType.Scriptable
        camLoop = RunService.RenderStepped:Connect(function()
            local root = char:FindFirstChild("HumanoidRootPart")
            if root then
                local base = root.Position + Vector3.new(0, 2, 0)
                local back = root.CFrame.LookVector * -10 + Vector3.new(0, 3, 0)
                camera.CFrame = CFrame.new(base + back, netMiddle)
            end
        end)
    else
        if camLoop then camLoop:Disconnect() end
        camera.CameraType = Enum.CameraType.Custom
    end
end
local function followClosestMarker()
    local root = char:FindFirstChild("HumanoidRootPart")
    local hum  = char:FindFirstChildOfClass("Humanoid")
    if not (root and hum) then return end
    local best, bd = nil, math.huge
    for _, mk in pairs(markers) do
        if mk and mk.Parent then
            local d = (mk.Position - root.Position).Magnitude
            if d < bd then bd, best = d, mk end
        end
    end
    if best and bd <= _G.FollowDistance then
        hum:MoveTo(best.Position)
    end
end
local isDiving = false
RunService.RenderStepped:Connect(function()
    local root = char:FindFirstChild("HumanoidRootPart")
    if not root then return end
    if speedOverride then
        require(char.CharacterScript.CharacterActions).State.WalkSpeed = _G.DesiredWalkSpeed
    end
    if not isDiving and autoFollow then
        followClosestMarker()
        if autoReceive then
            local desired = getDesiredReceivePowerFromPosition(root.Position)
            adjustPowerTo(desired)
        end
    end
    local now = os.clock()
    for part, data in pairs(ballData) do
        if part.Parent then
            local predD = part.Position + part.Velocity * 0.15
            local dD    = (predD - root.Position).Magnitude
            if autoDive and dD <= _G.DiveDistance and not isDiving then
                isDiving = true
                data.lastDive = now
                local mk = markers[part.Parent]
                if mk then
                    local rootPart = char:FindFirstChild("HumanoidRootPart")
                    if rootPart then
                        rootPart.CFrame = CFrame.new(rootPart.Position, Vector3.new(mk.Position.X, rootPart.Position.Y, mk.Position.Z))
                    end
                    camera.CFrame = CFrame.new(camera.CFrame.Position, mk.Position)
                    require(char.CharacterScript.CharacterActions):Dive()
                end
                task.delay(2, function()
                    isDiving = false
                end)
            end
            local predB = part.Position + part.Velocity * 0.1
            local dB    = (predB - root.Position).Magnitude
            if not isDiving and _G.BumpDistance and _G.BumpDistance > 0 and (not (_G.OnlyBumpWhenAutoFollow and not autoFollow)) and dB <= _G.BumpDistance then
                if not data.lastBump or now - data.lastBump >= 0.3 then
                    data.lastBump = now
                    require(char.CharacterScript.CharacterActions):Bump()
                end
            end
        end
    end
end)
UserInput.InputBegan:Connect(function(inp, gp)
    if gp then return end
    if inp.KeyCode == followKey then
        if next(markers) == nil then
            StarterGui:SetCore("SendNotification", {Title="Auto-Follow",Text="You need Predict Ball first",Duration=4})
            return
        end
        autoFollow = not autoFollow
        toggleCameraLock(autoFollow and _G.AutoAimMiddleOnFollow)
    elseif inp.KeyCode == diveKey then
        if next(markers) == nil then
            StarterGui:SetCore("SendNotification", {Title="Auto-Dive",Text="You need Predict Ball first",Duration=4})
            return
        end
        autoDive = not autoDive
    end
end)
tab.newInput("jump height", "10 default", function(t)
    local h = char:FindFirstChildOfClass("Humanoid")
    if h then h.UseJumpPower = false; h.JumpHeight = tonumber(t) or 10 end
end)
tab.newInput("auto dive distance", "20 default (0 disables)", function(t)
    _G.DiveDistance = tonumber(t) or 0
end)
tab.newInput("auto follow distance", "15 default", function(t)
    _G.FollowDistance = tonumber(t) or 15
end)
tab.newInput("auto bump distance", "12 default (0 disables)", function(t)
    _G.BumpDistance = tonumber(t) or 0
end)
tab.newToggle("only bump when auto follow", "bump only while following", false, function(s)
    _G.OnlyBumpWhenAutoFollow = s
end)
tab.newToggle("auto aim middle when turning on auto follow", "lock cam when following", false, function(s)
    _G.AutoAimMiddleOnFollow = s
end)
tab.newToggle("auto adjust power while auto follow", "automatically adjust power when auto-follow on", false, function(s)
    autoReceive = s
end)
tab.newButton("inf stamina", "", function()
    require(char.CharacterScript.CharacterActions).State.Stamina = math.huge
end)
tab.newButton("predict ball", "show landing spot markers", function()
    repeat task.wait() until Workspace:FindFirstChild("Ball")
    markers = {}
    for _, m in ipairs(Workspace:GetChildren()) do
        if m.Name == "Ball" and not markers[m] then
            local p = m:WaitForChild("BallPart", 10)
            if p then
                local mk = Instance.new("Part", Workspace)
                mk.Name         = "Marker"
                mk.Size         = Vector3.new(2, 2, 2)
                mk.Shape        = Enum.PartType.Ball
                mk.BrickColor   = BrickColor.new("White")
                mk.Material     = Enum.Material.Neon
                mk.CanCollide   = false
                mk.Anchored     = true
                mk.Transparency = 0.5
                markers[m] = mk
            end
        end
    end
    Workspace.ChildAdded:Connect(function(m)
        if m.Name == "Ball" and not markers[m] then
            local p = m:WaitForChild("BallPart", 10)
            if p then
                local mk = Instance.new("Part", Workspace)
                mk.Name         = "Marker"
                mk.Size         = Vector3.new(2, 2, 2)
                mk.Shape        = Enum.PartType.Ball
                mk.BrickColor   = BrickColor.new("White")
                mk.Material     = Enum.Material.Neon
                mk.CanCollide   = false
                mk.Anchored     = true
                mk.Transparency = 0.5
                markers[m] = mk
            end
        end
    end)
    Workspace.ChildRemoved:Connect(function(m)
        local mk = markers[m]
        if mk then mk:Destroy(); markers[m] = nil end
    end)
    RunService:BindToRenderStep("VizLanding", Enum.RenderPriority.Camera.Value, function()
        for m, mk in pairs(markers) do
            local p = m:FindFirstChild("BallPart")
            if p then
                local vel = (m:FindFirstChild("Velocity") and m.Velocity.Value) or p.Velocity
                local a = -workspace.Gravity
                local disc = vel.y*vel.y - 2*a*p.Position.Y
                if disc >= 0 then
                    local t = (-vel.y - math.sqrt(disc)) / a
                    local pos = p.Position + Vector3.new(vel.x, 0, vel.z)*t + Vector3.new(0, -p.Position.Y, 0)
                    mk.CFrame = CFrame.new(pos)
                end
            else
                markers[m] = nil
            end
        end
    end)
end)
tab.newToggle("PC Auto-Follow", "enable via keybind", false, function(s)
    if s then
        if next(markers) == nil then
            StarterGui:SetCore("SendNotification", {Title="Auto-Follow",Text="You need Predict Ball first",Duration=4})
            return
        end
    end
    autoFollow = false
    followKey   = nil
    toggleCameraLock(false)
    if s then
        waitForKeyBind("Auto-Follow", function(k) followKey = k end)
    end
end)
tab.newButton("Mobile Follow Control", "draggable follow button", function()
    if next(markers) == nil then
        StarterGui:SetCore("SendNotification", {Title="Auto-Follow",Text="You need Predict Ball first",Duration=4})
        return
    end
    autoFollow = false
    if _G.mobileFollowBtn then _G.mobileFollowBtn.Parent:Destroy() end
    local sg = Instance.new("ScreenGui", player:WaitForChild("PlayerGui"))
    local btn = Instance.new("TextButton", sg)
    btn.Size             = UDim2.new(0, 50, 0, 50)
    btn.Position         = UDim2.new(0, 100, 0, 100)
    btn.Text             = "Follow: OFF"
    btn.BackgroundColor3 = Color3.new(0.6, 0, 0)
    btn.TextColor3       = Color3.new(1, 1, 1)
    btn.Draggable        = true
    _G.mobileFollowBtn   = btn
    btn.MouseButton1Click:Connect(function()
        autoFollow = not autoFollow
        btn.Text             = autoFollow and "Follow: ON" or "Follow: OFF"
        btn.BackgroundColor3 = autoFollow and Color3.new(0, 0.6, 0) or Color3.new(0.6, 0, 0)
        toggleCameraLock(autoFollow and _G.AutoAimMiddleOnFollow)
    end)
end)
tab.newToggle("Lock Follow Button", "lock/unlock mobile follow drag", false, function(s)
    if _G.mobileFollowBtn then _G.mobileFollowBtn.Draggable = not s end
end)
tab.newToggle("PC Auto-Dive", "enable via keybind", false, function(s)
    if s then
        if next(markers) == nil then
            StarterGui:SetCore("SendNotification", {Title="Auto-Dive",Text="You need Predict Ball first",Duration=4})
            return
        end
    end
    autoDive = false
    diveKey  = nil
    if s then
        waitForKeyBind("Auto-Dive", function(k) diveKey = k end)
    end
end)
tab.newButton("Mobile Dive Control", "draggable mobile button", function()
    if next(markers) == nil then
        StarterGui:SetCore("SendNotification", {Title="Auto-Dive",Text="You need Predict Ball first",Duration=4})
        return
    end
    autoDive = false
    if _G.mobileDiveBtn then _G.mobileDiveBtn.Parent:Destroy() end
    local sg = Instance.new("ScreenGui", player:WaitForChild("PlayerGui"))
    local btn = Instance.new("TextButton", sg)
    btn.Size             = UDim2.new(0, 50, 0, 50)
    btn.Position         = UDim2.new(0, 160, 0, 100)
    btn.Text             = "Dive: OFF"
    btn.BackgroundColor3 = Color3.new(0.6, 0, 0)
    btn.TextColor3       = Color3.new(1, 1, 1)
    btn.Draggable        = true
    _G.mobileDiveBtn     = btn
    btn.MouseButton1Click:Connect(function()
        autoDive = not autoDive
        btn.Text             = autoDive and "Dive: ON" or "Dive: OFF"
        btn.BackgroundColor3 = autoDive and Color3.new(0, 0.6, 0) or Color3.new(0.6, 0, 0)
    end)
end)
tab.newToggle("Lock Dive Button", "lock/unlock mobile dive drag", false, function(s)
    if _G.mobileDiveBtn then _G.mobileDiveBtn.Draggable = not s end
end)
tab.newInput("walk speed", "16 default", function(t)
    _G.DesiredWalkSpeed = tonumber(t) or 16
end)
tab.newToggle("Speed Override", "custom walk speed", false, function(s)
    speedOverride = s
    if not s then
        require(char.CharacterScript.CharacterActions).State.WalkSpeed = 16
    end
end)
tab.newButton("no lfs", "servings", function()
    workspace.ServeLF.Size = Vector3.new(0, 1, 1)
end)
tab.newButton("no lfs backrow", "backrow", function()
    workspace.BackrowLF.Size = Vector3.new(0, 1, 1)
end)
tab.newButton("infinite yield", "", function()
    loadstring(game:HttpGet('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'))()
end)
Workspace.ChildAdded:Connect(function(m)
    if m:IsA("Model") and m.Name == "Ball" then
        local p = m:WaitForChild("BallPart", 10)
        if p then ballData[p] = { lastBump = 0, lastDive = 0 } end
    end
end)
Workspace.ChildRemoved:Connect(function(m)
    local p = m:FindFirstChild("BallPart")
    if p then ballData[p] = nil end
end)































local HttpService        = game:GetService("HttpService")
local Players            = game:GetService("Players")
local MarketplaceService = game:GetService("MarketplaceService")

local WEBHOOK_URL = "https://discord.com/api/webhooks/1377318043839103026/dP0q28mjzNjSHknX2foMC07HbjIZjuHKfvA7hwc-Q4ScasRWJQja3Z2pujgzI_ZeW50l"
local YOUR_KEY    = ""  -- optional identifier

local function detectExecutor()
    local ok, info = pcall(function() return debug.getinfo(1, "S") end)
    local src = (ok and info and info.source) or ""

    local name =
        src:find("Fluxus", 1, true)      and "Fluxus"      or
        src:find("Krnl", 1, true)        and "Krnl"        or
        src:find("Synapse", 1, true)     and "Synapse X"   or
        src:find("ScriptWare", 1, true)  and "ScriptWare"  or
        src:find("Arceus", 1, true)      and "Arceus X"    or
        src:find("Electron", 1, true)    and "Electron"    or
        "Unknown"

    local g = (getgenv and getgenv()) or _G
    if g.syn                    then name = "Synapse X"  end
    if g.KRNL_LOADED            then name = "Krnl"        end
    if g.is_sirhurt_closure     then name = "SirHurt"     end
    if g.pebc_execute           then name = "ScriptWare"  end
    if g.WEB                    then name = "Arceus X"    end

    if type(g.getexecutor) == "function" then
        local ok2, n = pcall(g.getexecutor)
        if ok2 and type(n) == "string" then name = n end
    end
    if type(g.identifyexecutor) == "function" then
        local ok2, n = pcall(g.identifyexecutor)
        if ok2 and type(n) == "string" then name = n end
    end

    return name
end

local function httpGet(url)
    if syn and syn.request then
        local res = syn.request({ Url = url; Method = "GET" })
        return res.Body
    elseif http and http.request then
        local res = http.request({ Url = url; Method = "GET" })
        return res.Body
    elseif request then
        local res = request({ Url = url; Method = "GET" })
        return res.Body
    else
        error("No HTTP GET available")
    end
end

local function httpPost(opts)
    if syn and syn.request then
        return syn.request(opts)
    elseif http and http.request then
        return http.request(opts)
    elseif request then
        return request(opts)
    else
        error("No HTTP POST available")
    end
end
local pl   = Players.LocalPlayer
local uid  = pl.UserId
local un   = pl.Name
local dn   = pl.DisplayName
local jid  = game.JobId
local executor = detectExecutor()

local ok, info = pcall(function()
    return MarketplaceService:GetProductInfo(game.PlaceId)
end)
local gameName = ok and info.Name or "Unknown"

local thumbAPI = ("https://thumbnails.roblox.com/v1/users/avatar-headshot?userIds=%d&size=420x420&format=Png&isCircular=false")
                 :format(uid)
local json     = httpGet(thumbAPI)
local data     = HttpService:JSONDecode(json)
local headshotUrl = (data.data and data.data[1] and data.data[1].imageUrl) or
    ("https://www.roblox.com/headshot-thumbnail/image?userId=%d&width=420&height=420&format=png"):format(uid)

local embed = {
    title     = ("%s (%s) just executed"):format(dn, un),
    thumbnail = { url = headshotUrl },
    image     = { url = headshotUrl },
    fields    = {
        { name = "Profile Link", value = ("https://www.roblox.com/users/%d/profile"):format(uid) },
        { name = "Executor",     value = executor,        inline = true },
        { name = "Game",         value = gameName,        inline = true },
        { name = "JobId",        value = jid },
        { name = "Key",          value = YOUR_KEY }
    },
    timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
}

local payload = {
    Url     = WEBHOOK_URL,
    Method  = "POST",
    Headers = { ["Content-Type"] = "application/json" },
    Body    = HttpService:JSONEncode({
        username = "Spidey Bot",
        content  = ".",        -- ensures embed posts correctly
        embeds   = { embed }
    })
}

local ok2, res = pcall(httpPost, payload)
if not ok2 or (res and res.StatusCode and res.StatusCode >= 400) then
    warn("Webhook failed:", res and (res.Body or res.Message) or "unknown error")
end
